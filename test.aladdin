infixn * 6.
prefix ~ 8.
infixl /\ 7.
infixl \/ 6.
infixn <-> 5.
prefix forall 5.
prefix exists 5.
infixn = 5.
infixn == 9.

kind * (type -> type -> type).
type pair (A -> B -> A * B).

kind term (type).
type fapp (string -> list term -> term).

kind formula (type).
type atom (string -> list term -> formula).
type _|_ (formula).
type ~ (formula -> formula).
type /\ (formula -> formula -> formula).
type \/ (formula -> formula -> formula).
type -> (formula -> formula -> formula).
type <-> (formula -> formula -> formula).
type forall ((term -> formula) -> formula).
type exists ((term -> formula) -> formula).
type = (term -> term -> formula).
type papp (property -> list term -> formula).

kind property (type).
type property_zero (formula -> property).
type property_succ ((term -> property) -> property).

kind scheme (type).
type mono_scheme (formula -> scheme).
type poly_scheme ((property -> scheme) -> scheme).

kind proof (type).
type by_axiom (string -> formula -> proof).
type by_assumption (formula -> proof).
type contradiction_intro (formula -> proof -> proof -> proof).
type contradiction_elim (formula -> proof -> proof).
type negation_intro (formula -> (formula -> proof) -> proof).
type negation_elim (formula -> (formula -> proof) -> proof).
type conjunction_intro (formula -> proof -> proof -> proof).
type conjunction_elim1 (formula -> proof -> proof).
type conjunction_elim2 (formula -> proof -> proof).
type disjunction_intro1 (formula -> proof -> proof).
type disjunction_intro2 (formula -> proof -> proof).
type disjunction_elim (formula -> proof -> (formula -> proof) -> (formula -> proof) -> proof).
type implication_intro (formula -> (formula -> proof) -> proof).
type implication_elim (formula -> proof -> proof -> proof).
type biconditional_intro (formula -> (formula -> proof) -> (formula -> proof) -> proof).
type biconditional_elim1 (formula -> proof -> proof -> proof).
type biconditional_elim2 (formula -> proof -> proof -> proof).
type universal_intro (formula -> (term -> proof) -> proof).
type universal_elim (formula -> proof -> proof).
type existential_intro (formula -> proof -> proof).
type existential_elim (formula -> proof -> (term -> formula -> proof) -> proof).
type equation_intro (formula -> proof).
type equation_elim1 (formula -> proof -> proof -> proof).
type equation_elim2 (formula -> proof -> proof -> proof).

kind proof_scheme (type).
type mono_proof (proof -> meta_proof).
type poly_proof ((property -> meta_proof) -> meta_proof).

type assoc (A -> B -> list (A * B) -> o).
assoc A B (pair A0 B0 :: Pairs) :- A = A0, !, B = B0; assoc A B Pairs.

type == (A -> A -> o).
(fapp Func Terms1) (fapp Func Terms2) :- Terms1 == Terms2.
[] == [] :- true.
(Term1 :: Terms1) == (Term2 :: Terms2) :- Term1 == Term2, Terms1 == Terms2.
(atom Pred Terms1) == (atom Pred Terms2) :- Terms1 == Terms2.
_|_ == _|_ :- true.
(~ Formula1) == (~ Formula1') :- Formula1 == Formula1'.
(Formula1 /\ Formula2) == (Formula1' /\ Formula2') :- Formula1 == Formula1', Formula2 == Formula2'.
(Formula1 \/ Formula2) == (Formula1' \/ Formula2') :- Formula1 == Formula1', Formula2 == Formula2'.
(Formula1 -> Formula2) == (Formula1' -> Formula2') :- Formula1 == Formula1', Formula2 == Formula2'.
(Formula1 <-> Formula2) == (Formula1' <-> Formula2') :- Formula1 == Formula1', Formula2 == Formula2'.
(forall Formula1) == (forall Formula1') :- pi (IVar\ IVar == IVar => Formula1 IVar == Formula1' IVar).
(exists Formula1) == (exists Formula1') :- pi (IVar\ IVar == IVar => Formula1 IVar == Formula1' IVar).
(papp Property1 Terms2) == (papp Property1' Terms2') :- Property1 == Property1', Terms2 == Terms2'. 
(property_zero Formula1) == (property_zero Formula1') :- Formula1 == Formula1'.
(property_succ Property1) == (property_succ Property1') :- pi (Formula\ Formula == Formula => Property1 Formula == Property1' Formula).

type subst ((A -> B) -> A -> B -> o).
subst HoledThing Hole Thing :- pi (HoleCopy\ HoleCopy == Hole => HoledThing HoleCopy == Thing).

type match_property (property -> list term -> formula -> o).
match_property (property_zero Formula1) [] Formula3 :- Formula1 == Formula3.
match_property (property_succ Property1) (Term2 :: Terms2) Formula3 :- sigma (Property\ match_property Property Terms2 Formula3, pi (IVar\ IVar == Term2 => Property1 IVar == Property)).

type instantiate_property ((property -> formula) -> formula -> property -> o).
instantiate_property (Property\ (atom Pred Terms1')) (atom Pred Term1') Property :- Terms1 == Terms1'.
instantiate_property (Property\ (_|_)) (_|_) Property :- true.
instantiate_property (Property\ (~ Formula1 Property)) (~ Formula1') Property :- instantiate_property Formula1 Formula1' Property.
instantiate_property (Property\ (Formula1 Property /\ Formula2 Property)) (Formula1' /\ Formula2') Property :- instantiate_property Formula1 Formula1' Property, instantiate_property Formula2 Formula2' Property.
instantiate_property (Property\ (Formula1 Property \/ Formula2 Property)) (Formula1' \/ Formula2') Property :- instantiate_property Formula1 Formula1' Property, instantiate_property Formula2 Formula2' Property.
instantiate_property (Property\ (Formula1 Property -> Formula2 Property)) (Formula1' -> Formula2') Property :- instantiate_property Formula1 Formula1' Property, instantiate_property Formula2 Formula2' Property.
instantiate_property (Property\ (Formula1 Property <-> Formula2 Property)) (Formula1' <-> Formula2') Property :- instantiate_property Formula1 Formula1' Property, instantiate_property Formula2 Formula2' Property.
instantiate_property (Property\ (papp Property Terms)) Formula Property :- match_property Property Terms Formula.

type instantiate_scheme (scheme -> formula -> list property -> o).
instantiate_scheme (mono_scheme Formula1) Formula2 [] :- Formula1 == Formula2.
instantiate_scheme (poly_scheme Scheme1) Formula2 (Property3 :: Properties3) :- sigma (Formula\ pi (Property\ Property == Property => instantiate_scheme (Scheme1 Property) (Formula Property) Properties3), instantiate_property Formula Formula2 Property3).
